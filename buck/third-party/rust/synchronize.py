#!/usr/bin/env python3

# synchronize.py: sync workspace Cargo.toml with buck2/reindeer Cargo.toml

import re
import subprocess
import tomllib

# the workspace Cargo.toml file does not allow expressing conditional
# dependencies, but it functions as the source of truth for all version data,
# and if we want to update third-party//rust with correct platform-specific
# dependencies, we need to parse it, then emit a valid version

WINDOWS_DEPS = [ ]
UNIX_DEPS = [ ]

CARGO_TEMPLATE = """# @generated by buck/third-party/rust/synchronize.py
[workspace]

[package]
name = "rust-third-party"
version = "0.0.0"
publish = false
edition = "2021"

# Dummy target to keep Cargo happy
[[bin]]
name = "top"
path = "top.rs"

"""

def format_dep(rhs) -> str:
    # if it's a string, just print it out
    if isinstance(rhs, str):
        return f'"{rhs}"'
    elif isinstance(rhs, bool):
        return f'{str(rhs).lower()}'
    # if it's a list, format it as a toml array
    elif isinstance(rhs, list):
        return f'[ {", ".join([f'"{x}"' for x in rhs])} ]'
    else:
        # format the dict as a toml dict manually
        return "{ " + ", ".join([f'{k} = {format_dep(v)}' for k, v in rhs.items()]) + " }"

def sync_cargo_deps():
    contents = CARGO_TEMPLATE
    with open ("Cargo.toml", "rb") as f:
        # parse the workspace Cargo.toml
        data = tomllib.load(f)
        deps = data["workspace"]["dependencies"]

        # add build-dependencies to the normal set of deps
        if "build-dependencies" in data:
            for x, v in data["build-dependencies"].items():
                deps[x] = v

        contents += "[dependencies]\n"
        for x, v in deps.items():
            # some crates are only for one platform; we need to remove them and
            # handle it below
            if x in WINDOWS_DEPS or x in UNIX_DEPS:
                continue
            contents += f'{x} = {format_dep(v)}\n'

        contents += ("\n[target.'cfg(unix)'.dependencies]\n")
        for x in UNIX_DEPS:
            contents += f'{x} = {format_dep(deps[x])}\n'

        contents += ("\n[target.'cfg(windows)'.dependencies]\n")
        for x in WINDOWS_DEPS:
            contents += f'{x} = {format_dep(deps[x])}\n'

    # now write the contents to buck/third-party/rust/Cargo.toml
    print("Writing new buck/third-party/rust/Cargo.toml")
    with open("buck/third-party/rust/Cargo.toml", "w") as f:
        f.write(contents)

    # get the path to 'rustc' and 'cargo' directly from the buck targets under
    # toolchains//:rust
    get_rust_tool = lambda tgt: [
        "./buck/bin/buck2",
        "build",
        "--show-full-simple-output",
        "toolchains//:rust[{}]".format(tgt),
    ]

    result = subprocess.run(get_rust_tool('cargo'), check=True, capture_output=True)
    cargo = result.stdout.decode("utf-8").strip()

    result = subprocess.run(get_rust_tool('rustc'), check=True, capture_output=True)
    rustc = result.stdout.decode("utf-8").strip()

    # now run reindeer
    print("Now running 'reindeer' to regenerate BUILD files")
    cmd = [
        "./buck/bin/reindeer",
        "--rustc-path", rustc,
        "--cargo-path", cargo,
        "--third-party-dir",
        "buck/third-party/rust",
        "buckify",
    ]
    subprocess.run(cmd, check=True)

    # Now run 'buck2 build' to make sure everything is up to date
    print("Now running 'buck2 build' to make sure everything works")
    cmd = [
        "buck2",
        "build",
        "@mode//debug",
        "third-party//rust",
    ]
    subprocess.run(cmd, check=True)

BUILD_FILES= [
    ('tools/cache-server/BUILD', 'tools/cache-server/Cargo.toml'),
]

def update_buck_files():
    for (buck_file, cargo_file) in BUILD_FILES:
        print("Updating", buck_file, "with", cargo_file)
        # load cargo_file into a dict
        with open(cargo_file, "rb") as f:
            cargo_data = tomllib.load(f)

        CARGO_START_RE = re.compile(r'(\s*)# CARGO-SYNC-START: (\S+)')
        CARGO_END_RE = re.compile(r'(\s*)# CARGO-SYNC-END')

        lines = []
        with open(buck_file, "r") as f:
            # walk over the lines until we match CARGO_START_RE, and then
            # capture that line and the next one by appending them to lines,
            # then stop until we match CARGO_END_RE
            capturing = True
            middle = False
            for line in f:
                if capturing:
                    lines.append(line)

                if middle:
                    middle = False

                    # now print out the real deps
                    prefix = ' ' * indent_size
                    dep_lines = []

                    # if the captured name ends with "@cfg($FOO)", then capture
                    # $FOO and use it to select the proper target-specific cargo
                    # deps
                    m = re.compile(r'\S+\@cfg\((\S+)\)').match(captured_name)
                    if m != None:
                        plat = f'cfg({m.group(1)})'
                        deps = cargo_data["target"][plat]["dependencies"]
                    else:
                        deps = cargo_data[captured_name]

                    for k, _ in deps.items():
                        new_line = prefix
                        new_line += f"'third-party//rust:{k}',\n"
                        dep_lines.append(new_line)

                    dep_lines = sorted(dep_lines)
                    lines.extend(dep_lines)

                if CARGO_START_RE.match(line):
                    middle = True
                    capturing = False
                    indent_size = len(CARGO_START_RE.match(line).group(1))
                    captured_name = CARGO_START_RE.match(line).group(2)
                if CARGO_END_RE.match(line):
                    lines.append(line)
                    capturing = True

        contents = "".join(lines)
        if False:
            # XXX FIXME: remove this debug path
            print(contents)
        else:
            with open(buck_file, "w") as f:
                f.write(contents)

if __name__ == "__main__":
    update_buck_files()
    sync_cargo_deps()
